#include "csharp/csharp_generator.h"

#include <string>
#include <vector>

#include "google/protobuf/empty.pb.h"
#include "google/protobuf/io/printer.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"

#include "closetrpc_types.pb.h"

#include "common/generator_utils.h"

namespace {
// TODO(jtattermusch): can we reuse a utility function?
std::string UnderscoresToCamelCase(const std::string &input,
                                   bool cap_next_letter,
                                   bool preserve_period) {
  std::string result;
  // Note:  I distrust ctype.h due to locales.
  for (int i = 0; i < input.size(); i++) {
    if ('a' <= input[i] && input[i] <= 'z') {
      if (cap_next_letter) {
        result += input[i] + ('A' - 'a');
      } else {
        result += input[i];
      }
      cap_next_letter = false;
    } else if ('A' <= input[i] && input[i] <= 'Z') {
      if (i == 0 && !cap_next_letter) {
        // Force first letter to lower-case unless explicitly told to
        // capitalize it.
        result += input[i] + ('a' - 'A');
      } else {
        // Capital letters after the first are left as-is.
        result += input[i];
      }
      cap_next_letter = false;
    } else if ('0' <= input[i] && input[i] <= '9') {
      result += input[i];
      cap_next_letter = true;
    } else {
      cap_next_letter = true;
      if (input[i] == '.' && preserve_period) {
        result += '.';
      }
    }
  }
  // Add a trailing "_" if the name should be altered.
  if (input[input.size() - 1] == '#') {
    result += '_';
  }
  return result;
}

std::string UnderscoresToPascalCase(const std::string &input) {
  return UnderscoresToCamelCase(input, true, false);
}

}  // namespace

namespace closetrpc_csharp_codegen {

namespace pb = google::protobuf;
namespace pbc = google::protobuf::compiler;

std::string GetFileNamespace(const pb::FileDescriptor *descriptor) {
  if (descriptor->options().has_csharp_namespace()) {
    return descriptor->options().csharp_namespace();
  }
  return UnderscoresToCamelCase(descriptor->package(), true, true);
}

bool IsVoidType(const pb::Descriptor *type) {
  return type == nullptr ||
         type->full_name() == pb::Empty::descriptor()->full_name();
}

std::string GetMethodSignature(const pb::MethodDescriptor &method,
                               ContextType type) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    auto method_name = method.name();
    if (type == ContextType::EventStub)
      method_name = GetEventMethodName(method_name);

    vars["server_context_type"] = kServerContextType;
    vars["event_source_type"] = kRpcEventSourceType;
    vars["method_name"] = method_name;
    vars["output_type_name"] = method.output_type()->name();

    if (IsVoidType(method.output_type()))
      vars["output_type_name"] = "void";

    printer.Print(vars, "$output_type_name$ $method_name$(");

    bool has_context_argument = true;
    if (type == ContextType::Stub)
      printer.Print(vars, "$server_context_type$ context");
    else if (type == ContextType::EventProxy)
      printer.Print(vars, "$event_source_type$ eventSource");
    else
      has_context_argument = false;

    if (!IsVoidType(method.input_type())) {
      vars["input_type_name"] = method.input_type()->name();
      if (has_context_argument)
        printer.Print(", ");
      printer.Print(vars, "$input_type_name$ value");
    }

    printer.Print(")");
  }

  return output;
}

void GetSourcePrologue(pb::io::Printer &printer,
                       const pb::FileDescriptor &file) {
  std::map<std::string, std::string> vars;

  vars["filename"] = GetFileNamespace(&file);
  vars["ns"] = GetFileNamespace(&file);

  /* clang-format off */
  printer.Print(vars, "// Generated by the nanorpc protobuf plugin.\n");
  printer.Print(vars, "// If you make any local change, they will be lost.\n");
  printer.Print(vars, "// source: $filename$\n\n");
  /* clang-format on */

  if (!file.package().empty()) {
    printer.Print(vars, "namespace $ns$\n{\n");
    printer.Indent();
    printer.Print(vars, "using System;\n");
    printer.Print(vars, "using Google.Protobuf;\n");
    printer.Print(vars, "using Google.Protobuf.WellKnownTypes;\n");
    printer.Outdent();
    printer.Print(vars, "\n");
  }
}

void GetSourceEpilogue(pb::io::Printer &printer,
                       const pb::FileDescriptor &file) {
  std::map<std::string, std::string> vars;

  if (!file.package().empty()) {
    printer.Print("}\n");
  }
}

}  // namespace closetrpc_csharp_codegen
